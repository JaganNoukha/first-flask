# .github/workflows/deploy-flask-app.yml
name: Deploy Flask App

on:
  workflow_dispatch: # This allows you to manually trigger the workflow from the GitHub UI
    inputs:
      build_artifact_name:
        description: 'Name of the artifact to deploy'
        required: true
        default: 'flask-app-build' # Default to the artifact name from the build workflow

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Download Flask App Artifact
      uses: actions/download-artifact@v4 # Downloads the artifact created by the build workflow
      with:
        name: ${{ github.event.inputs.build_artifact_name }} # Use the input artifact name

    - name: Deploy via SSH to EC2
      uses: appleboy/ssh-action@v0.1.10 # Connects to your EC2 instance via SSH
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
        script: |
          # Define the target directory on your EC2 instance
          TARGET_DIR="/home/${{ secrets.EC2_USERNAME }}/first-flask" # Adjust if your username is not 'ubuntu' or directory is different

          # Create the target directory if it doesn't exist
          echo "Ensuring target directory exists: $TARGET_DIR"
          mkdir -p "$TARGET_DIR"

          # Synchronize files from the GitHub Actions runner to EC2
          # The artifact is downloaded into the current working directory of the runner.
          echo "Synchronizing application files to EC2..."
          # Use rsync for efficient syncing; '-a' for archive mode, '--delete' to remove old files
          # IMPORTANT: The source path './' refers to the downloaded artifact content
          rsync -avz --exclude 'venv/' --exclude '.git/' ./ "$TARGET_DIR"/

          # Change to the application directory on EC2
          cd "$TARGET_DIR"

          # --- Virtual Environment Setup on EC2 ---
          # Create virtual environment if it doesn't exist within the deployed app directory
          if [ ! -d "venv" ]; then
            echo "Creating virtual environment..."
            python3 -m venv venv
          fi

          # Activate the virtual environment
          echo "Activating virtual environment..."
          source venv/bin/activate

          # Install any new or updated Python dependencies (important if requirements.txt changes)
          echo "Installing/updating Python dependencies..."
          pip install -r requirements.txt

          # --- Production WSGI Server (Gunicorn) ---
          # Stop any existing Gunicorn process running this app
          echo "Stopping existing Gunicorn Flask app (if running)..."
          # pkill -f 'gunicorn --bind 0.0.0.0:5000 app:app' for more specific kill, or just 'gunicorn'
          pkill -f 'gunicorn' || true # Use '|| true' to prevent script failure if no process is found

          # Start the Flask app using Gunicorn in the background
          # Assumes your Flask application instance is named 'app' in 'app.py' (app:app)
          # Binds to all interfaces (0.0.0.0) on port 5000.
          echo "Starting new Flask app with Gunicorn..."
          # Use the python interpreter from the active virtual environment
          nohup gunicorn --workers 4 --bind 0.0.0.0:5000 app:app > app.log 2>&1 &

          echo "Deployment complete! Check your EC2 public IP on port 5000."
